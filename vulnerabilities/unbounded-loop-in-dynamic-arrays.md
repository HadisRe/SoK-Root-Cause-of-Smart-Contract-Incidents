# Unbounded Loops in Dynamic Arrays
When a loop in a SC runs over all elements of a dynamic array, the gas cost for executing the loop will by the number of elements. If the array grows over time or contains many elements, the gas cost may exceed the block gas limit. This can lead to the failure of the function's execution and result in a DoS attack. Specifically, if operations like clearing or modifying array elements in large arrays are performed, the gas costs for processing these arrays may become too high, preventing the function from completing successfully and leading to DoS attacks.

## Toy Example
```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UnboundedLoopExample {
    address[] public users;

    function addUser(address _user) public {
        users.push(_user);
    }

    function clearUsers() public {
        for (uint i = 0; i < users.length; i++) {
            users[i] = address(0); //  If the array is too large, this loop may exceed the block gas limit,
                                   // causing the transaction to revert and making the function unusable.
        }
    }
}

```

## REal World Example
In 2016, the GovernMental smart contract suffered from an Unbounded Loop vulnerability, which resulted in 1100 Ether (approximately $2.5 million at the time) being locked and users losing access to their funds. This issue arose due to a hidden loop generated by the Solidity compiler when developers attempted to reset an array using the pattern creditorAddresses = new address[];. At first glance, this might seem like a simple reset operation. However, due to Solidity's internal memory management, this statement was translated into a loop in the EVM bytecode that iterated over all elements of the creditorAddresses array and set each to 0, effectively deleting them. The compiled pseudocode looked like foreach a ∈ array A do a ← 0; , meaning the loop execution cost was directly proportional to the number of creditors in the array.

Since Ethereum imposes a block gas limit, when the number of creditors in the creditorAddresses array grew large, the gas required to execute the loop exceeded this limit. As a result, the transaction reverted, preventing the function from completing its task. Unfortunately, this function was essential for fund withdrawal, meaning that once the loop failed, all Ether stored in the contract became permanently locked, making it inaccessible to users. There was no fallback mechanism or alternative function to recover the locked funds.

The vulnerability was triggered by a combination of dynamic array growth and unexpected gas consumption from implicit loops. Every time a new creditor participated, the creditorAddresses array expanded. However, when the contract attempted to reset the array, the loop iterated over all stored addresses, deleting them one by one. As the array size increased, so did the execution cost of the loop. When the number of creditors reached a certain threshold, the gas needed to complete the operation exceeded the Ethereum block gas limit, causing the function execution to fail and revert. Because this function was responsible for clearing and managing payouts, its failure led to the permanent loss of all locked funds in the contract.


## References
[1] Ghaleb, A., Rubin, J., & Pattabiraman, K. (2022, July). eTainter: detecting gas-related vulnerabilities in smart contracts. In Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis (pp. 728-739).

[2] https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/
